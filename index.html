<!DOCTYPE html>
<html lang="en">
   <head>
    <meta charset="UTF-8">
    <title>KYCManager front-end</title>
    <script language="javascript" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://unpkg.com/@metamask/detect-provider/dist/detect-provider.min.js"></script>
    <script language="javascript" type="text/javascript" src="./src/js/web3.min.js"></script>
    <script language="javascript" type="text/javascript" src="./src/js/KYCManager_ABI.js"></script>
    <script language="javascript" type="text/javascript" src="./src/js/KYCNFT_ABI.js"></script>
    <script language="javascript" type="text/javascript" src="./src/js/testAddress.js"></script>
    <script language="javascript" type="text/javascript" src="./src/js/bignumber.js"></script>

     
  </head>
  <body>
    <div id="txStatus"></div>
    <input type="text" id="inputOwnerAddr" oninput="getOwnerAddr();" onporpertychange="getOwnerAddr();" placeholder="inout owner address">
    <button class="createKYCNFTButton btn">CreateKYCNFT</button><br>
    <button class="enableEthereumButton btn">Enable Ethereum</button>
    <button class="sendEthButton btn">Send Eth</button>
    <button class="updateAccumulatorButton btn">update Accumulator For Owner</button>
    <button class="getAccumulatorButton btn">get Accumulator For Owner</button>
    <script>
      /*
        KYCManager Owner：0x892953Cb6cDC87c8aD7c4aAfb06A716CBa231D8a
      */
      
      var KYCManager;
      var KYCManagerAddress = "0xe0ABBFeD0C089FE32750e342b82B1e95948c8cca";
      
      var web3js =  window.web3 ? new Web3(window.web3.currentProvider) : new Web3(new Web3.providers.HttpProvider("https://goerli.infura.io/v3/de1e8657274a494aa59476341cafc010"));;
      
     
      
      function startApp() {
        console.log(" ******  start App   ******")
        
        KYCManager = new web3js.eth.Contract(kycManagerABI, KYCManagerAddress);
        
        //test
        getOwnerOfNFTid(4).then(function(result, error) {
         if(error){
           console.log(error);
         }
         else{
           var strA = "0x0000000000000000000000000000000000000000";
           var strB = new String(result);
           if(strA == strB){
              console.log("NFT not exist!")
           }else{
              console.log("OwnerOfNFTid 4: " + JSON.stringify(result))
           }
           
         }
        });


        
        //test 
        getAccumulatorOfOwner('0xE338401152596583EeC184061F504D7600B59Ea6').then(function(result, error) {
         if(error){
           console.log(error);
         }
         else{
           console.log("AccumulatorAddrOfOwner: " + JSON.stringify(result));
         }
        });
        //获取metamask账户
        getAccount();
        

        
        
      }
      
      
    
       /********************************************************    Call Contract by web3js      **************************************************************************************/
      


      /*
      getBalance
      */
      function getBalance(address){
         web3js.eth.getBalance(address,function(error,result){
         if(error){
           console.log(error)
         }
         else{
           console.log(result)
           
         }
        }) 
      }
      
       
      /*
       (1) 创建NFT（ owner权限）
      */
      
       function createKYCNFT(tokenUrl, manager) {
        $("#txStatus").text("Creating KYCNFT on the blockchain. This may take a while...");

        return KYCManager.methods.createKYCNFT(tokenUrl, manager)
        .send({ from: web3.eth.accounts[0]})
        .on("receipt", function(receipt) {
          $("#txStatus").text("Successfully created " + tokenUrl + "for manager" + manager + "!");
        })
        .on("error", function(error) {
          $("#txStatus").text(error);
        });
    
      }
      
      
    /*
       (2) 设置NFT有效性
    */
       function setKYCNFTAvailable(NFTid, available) {
        $("#txStatus").text("Set KYCNFT Available This may take a while...");
        
        return KYCManager.methods.setNFTAvailable(NFTid, available)
        .send({ from: web3.eth.accounts[0]})
        .on("receipt", function(receipt) {
          $("#txStatus").text("Successfully set " + NFTid + "to Available" + available + "!");
        })
        .on("error", function(error) {
          $("#txStatus").text(error);
        });
      }
      
      
      
     /*
      （3）Map1:绑定NFTid与管理地址
     */
 
     //create是owner权限
       function createNFTidToManagerAddr(NFTid, manager) {
        $("#txStatus").text("Set create NFTid to ManagerAddr This may take a while...");

        return KYCManager.methods.createNFTidToManagerAddr(NFTid, manager)
        .send({ from: web3.eth.accounts[0]})
        .on("receipt", function(receipt) {
          $("#txStatus").text("Successfully create NFTid " + NFTid + "to ManagerAddr" + manager + "!");
        })
        .on("error", function(error) {
          $("#txStatus").text(error);
        });
   
 
      }  
    //modify是Manager addr权限
      function modifyNFTidToManagerAddr(NFTid, newManager) {
        $("#txStatus").text("Set modify NFTid to ManagerAddr. This may take a while...");
        
        return KYCManager.methods.modifyNFTidToManagerAddr(NFTid, newManager)
        .send({ from: web3.eth.accounts[0]})
        .on("receipt", function(receipt) {
          $("#txStatus").text("Successfully modify NFTid " + NFTid + "to ManagerAddr" + newManager + "!");
        })
        .on("error", function(error) {
          $("#txStatus").text(error);
        });
      }



    /*
      （4）Map2:绑定管理地址与累加器（查询管理地址已经有了对应的KYCNFT）
    */

      function setUpAccumulator(Accumulator, modN, generator) {
        $("#txStatus").text("Bind Manger to Accumulator. This may take a while...");
        
        return KYCManager.methods.updateAccumulator(Accumulator, modN, generator)
        .send({ from: web3.eth.accounts[0]})
        .on("receipt", function(receipt) {
          $("#txStatus").text("Successfully update Manger " + web3.eth.accounts[0] + "to addrOfAccumulator" + addrOfAccumulator + "!");
        })
        .on("error", function(error) {
          $("#txStatus").text(error);
        });
      }

      function updateAccumulator(Accumulator) {
        $("#txStatus").text("Bind Manger to Accumulator. This may take a while...");
        
        return KYCManager.methods.updateAccumulator(Accumulator)
        .send({ from: web3.eth.accounts[0]})
        .on("receipt", function(receipt) {
          $("#txStatus").text("Successfully update Manger " + web3.eth.accounts[0] + "to addrOfAccumulator" + addrOfAccumulator + "!");
        })
        .on("error", function(error) {
          $("#txStatus").text(error);
        });
      }
  
  
      
      
    /*
       （5）查询某NFT id对应的管理地址与累加器地址
    */
      //由NFTid 找Owner地址
      function getOwnerOfNFTid(id) {
        return KYCManager.methods.ownerOfNFTid(id).call()
      }
      
       //由NFTid 找Accumulator
      function getAccumulatorOfNFTID(id) {
        return KYCManager.methods.accumulatorOfNFTID(id).call()
      }
      
      //由Owner 找Accumulator
      function getAccumulatorOfOwner(owner) {
        return KYCManager.methods.accumulatorOfOwner(owner).call()
      }
      
       //由NFTid查询有效性
      function getAvailableOfNFTid(id) {
        return KYCManager.methods.availableOfNFTid(id).call()
      }
       //由Manager addr找由NFTid
      function getNFTidOfOwner(owner) {
        return KYCManager.methods.NFTidOfOwner(owner).call()
      }
     
     /********************************************************    UI      **************************************************************************************/
     
    var ownerAddr = document.getElementById("inputOwnerAddr").value;;
    function getOwnerAddr(){
	    ownerAddr = document.getElementById("inputOwnerAddr").value;
		console.log("inputOwnerAddr = " + ownerAddr);
	}


    const ethereumButton = document.querySelector('.enableEthereumButton');
    const sendEthButton = document.querySelector('.sendEthButton');
    const createKYCNFTButton = document.querySelector('.createKYCNFTButton');
    const updateAccumulatorButton = document.querySelector('.updateAccumulatorButton');
    const getAccumulatorButton = document.querySelector('.getAccumulatorButton');
    let accounts = [];

    ethereumButton.addEventListener('click', () => {
       getAccount();
    });

    sendEthButton.addEventListener('click', () => {
       ethereum
      .request({
         method: 'eth_sendTransaction',
         params: [
         {
          from: accounts[0],
          to: '0xE338401152596583EeC184061F504D7600B59Ea6',
          value: '0x29a2241af62c0000',
          gasPrice: '0x09184e72a000',
          gas: '0x2710',
         },
       ],
       })
      .then((txHash) => console.log(txHash))
      .catch((error) => console.error);
    });
   
    async function getAccount() {
       accounts = await ethereum.request({ method: 'eth_requestAccounts' });
    }
    
   
    createKYCNFTButton.addEventListener('click', () => {
        createKYCNFT("ipfs://ipfsHash",ownerAddr).then(function(result, error) {
         if(error){
           console.log(error)
         }
         else{
           console.log("create KYCNFT Success !: " + JSON.stringify(result));
         }
        });
        
    });
    
    updateAccumulatorButton.addEventListener('click', () => {
         //test
         //accumulator = BigNumber("25195908475657893494027183240048398571429282126204032027777137836043662020707595556264018525880784406918290641249515082189298559149176184502808489120072844992687392807287776735971418347270261896375014971824691165077613379859095700097330459748808428401797429100642458691817195118746121515172654632282216869987549182422433637259085141865462043576798423387184774447920739934236584823824281198163815010674810451660377306056201619676256133844143603833904414952634432190114657544454178424020924616515723350778707749817125772467962926386356373289912154831438167899885040445364023527381951378636564391212010397122822120720357")
         updateAccumulator(accumulator.toString()).then(function(result, error) {
         if(error){
           console.log(error)
         }
         else{
           console.log("update Accumulator Success !: " + JSON.stringify(result));
         }
        });
    });

    getAccumulatorButton.addEventListener('click', () => {
        getAccumulatorOfOwner(ownerAddr).then(function(result, error) {
         if(error){
           console.log(error);
         }
         else{
           console.log("AccumulatorAddrOfOwner: " + JSON.stringify(result));
         }
        });
        
    });


     /*
    ***********************************************************     Metamask check      *****************************************************************************************
    
    What metamask do is inject javascript into the document when you access it. The browser will execute this javascript, and is that execution that will define de variable web3.

    But when you are accessing a document by accessing the file (your url will start with file://) then metamask will not inject the javascript, so the variable web3 will be undefined.

    Try accessing your file through a web server of some sort and it will work.
    
     */
   

    
    window.addEventListener('load', function() {

       _Connect()
      
       startApp(); 
    }) 
     
     
     
   /*
   mainnet	ETH	1	1	Production
   ropsten	ETH	3	3	Test
   rinkeby	ETH	4	4	Test
   goerli	ETH	5	5	Test
   */
    
   function _Connect(){

    if(typeof window.ethereum !== 'undefined') {
        if(web3js.currentProvider.isMetaMask){
          console.log("CurrentProvider is MetaMask");
        }else {
          console.log(`Failed: Web3 instance required, try using MetaMask.`);
          alert('Install Metamask');
        } 
       
        console.log("netId = " + web3js.currentProvider.networkVersion)
        switch (web3js.currentProvider.networkVersion) {
          case "1":
           // alert('Ethereum MainNet'); 
            console.log('Ethereum MainNet');
            break
          case "3":
           // alert('Ethereum Ropsten'); 
            console.log('Ethereum Ropsten');
            break    
          case "4":
            //alert('Ethereum Rinkeby'); 
            console.log('Ethereum Rinkeby');
            break   
          case "5":
            //alert('Ethereum Goerli'); 
            console.log('Ethereum Goerli');
            break   
            
          default:
            console.log('This is an unknown network.');
            alert('Switch Network');
        }
        web3.eth.defaultAccount = web3.eth.accounts[0];
        if(!web3.eth.defaultAccount){
            console.log('Log into metamask');
        }else{ 
            // Success
            console.log(`Web3 ETH Account: ${web3.eth.defaultAccount}`);
        } 
              
    }
    }
          
   
    /********************************************************    Accumulator      **************************************************************************************/
   /*
    累加器中的系统参数包括生成元g，两个大质数p和q，模数N = pq 。
    其中，g和N属于公钥部分，可以公开；N的因式分解，即p和q属于私钥，不能公开。
    外人在仅知道N的值的时候，是无法计算出p和q的值的。
    另外，这里为了加强安全性，还特别要求在随机生成p和q的时候，需要保证(p-1)/2和(q-1)/2也是质数。
    这样，n的欧拉函数 f(n) = (p-1)(q-1)只有三个因子2，（p-1）/2，（q-1）/2, 减少了累加器元素与N不互素的概率。
    由于保证(p-1)/2和(q-1)/2也是质数需要的时间较长，且事实上非必要，因此只寻找满足p，q为素数

    N的生成
    该系统的一个缺点是它需要模数N是两个素数的乘积，但Alice必须不知道这些因子。那里有两种方法。
    Bob可以自己生成 N 并要求Alice用它来证明，这样Bob就能信任证明结果。但Bob可以利用他的因子来伪造累加器和证据，因此其他人不会信任这样的结果，并且Alice有否定权。
    但我们真正想要的是公开使用该系统，为此我们需要一个值得信赖的启动。这意味着某些计算机必须从随机因素中生成 N，并忘记这些因子。如果有人认为这些因素没有被任何人保存，那么他就可以信任该系统。
     
    我们让第三方的provider来设置N，这样用户和验证者都不知道p,q
    */
    //param 1: N -> public 
    //         p,q -> delete
    
    class ModNumber{
         constructor(p,q){
           this.N=p.times(q);
           this.p=p;
           this.q=q;
           this.fn=(q.minus(1)).times(p.minus(1));
         }
    }
    /* 找两个大素数p，q，找出N对应的欧拉函数 
    https://zh.wikipedia.org/wiki/已知最大質數
    M607 = 531137992816767098689588206552468627329593117727031923199444138200403559860852242739162502265229285668889329486246501015346579337652707239409519978766587351943831270835393219031728127
    M521 = 6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151
    180×(M127)2+1 = 5210644015679228794060694325390955853335898483908056458352183851018372555735221
                    
    modNum = 3.577001684660833676469200409969e+235
    */
    
    const modNum = new ModNumber(BigNumber(531137992816767098689588206552468627329593117727031923199444138200403559860852242739162502265229285668889329486246501015346579337652707239409519978766587351943831270835393219031728127),BigNumber(6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151));
    console.log("RSA1024 = " + BigNumber(135066410865995223349603216278805969938881475605667027524485143851526510604859533833940287150571909441798207282164471551373680419703964191743046496589274256239341020864383202110372958725762358509643110564073501508187510676594629205563685529475213500852879416377328533906109750544334999811150056977236890927563))
    const N = modNum.N;
    const p = BigNumber(modNum.p);
    const q = BigNumber(modNum.q);
    const fn = modNum.fn;
    console.log("modNum = "+ N + " p = " + p  
    + "q = " + q + " p-1 = " + (p.minus(1)) 
    + " q-1 = " + (q.minus(1)) + " fn = " + fn)


    function powInMod(a, y, z) {
      let x = BigNumber(1);
      while(y.comparedTo(0) == 1) {
        if(y.mod(2).toNumber() === 1) {
          x = (x.times(a)).mod(z);
          y = y.minus(1);
        }
        y = y.div(2);
        a = a.times(a).mod(z);
      }
      return x;
    }

    
    class RSAaccumulator {
      //更新累加器
      static addItemToAccumulator(accumulator, value) {
        return powInMod(accumulator, value, N);
      }
      
      static deleteItemFromAccumulator(accumulator, value ,inclusionProofOfValue) {
        if(RSAaccumulator.checkInclusionProof(accumulator, inclusionProofOfValue) == false){
           console.log(value.toNumber() + "is not a member of accumulator !" )
           return accumulator
        }
        //inverse Of value mod fn
        var inverseOfvalue = modInverse(value,modNum.fn)
        var newAccumulator = powInMod(accumulator,inverseOfvalue,N)
        console.log("delete successed !")
        return  newAccumulator
      }

     //获取成员证明
     //每次更新累加器后重新使用原始数据生成证明
      static getProof(setValues, value, generator){
       let proofvalue = generator;
       for(let i = 0; i < setValues.length; i++){
         if(!setValues[i].eq(value)){
            proofvalue = powInMod(proofvalue, setValues[i], N);
         }
       }
       //console.log("proofvalue = " + proofvalue + " value = " + value)
       return new RSAaccumulatorProof(value, proofvalue);
     }
    

     //检查成员证明
     static checkInclusionProof(accumulator, proof){
       //console.log("proofvalue = " + proof.proof + " value = " + proof.value)
       return accumulator.eq(powInMod(proof.proof,proof.value,N))
     }
   }
   
    class RSAaccumulatorProof{
         constructor(value,proofvalue){
           this.value=value;
           this.proof=proofvalue;
         }
    }

    /*
    find y^-1 mod (fn), fn =(p-1)(q-1)
    a*fn + by = 1   ----->    a*fn + by mod(fn) = by mod(fn) = 1 mod(fn)
    */
    function modInverse(y, fn){
       const [a, b, g] = extendedGcd(fn, y);
       //console.log("a = " + a + " fn = " + fn + " b = " + b + " y = " + y  + " g = " + g)
       //console.log("a*fn + by = " + (a.times(fn).plus(b.times(y))).toNumber())
       //console.log("b = " + b.toNumber() + " y = " + y.toNumber() + " by mod fn = " + (b.times(y).mod(fn)).toNumber())
       let result = b.mod(fn)
       //console.log("mod inverse result 1= " + result.toNumber())
       while(result.lt(0)){
        result = result.plus(fn)
       }
       //console.log("mod inverse result 2= " + result.toNumber())
       return result;
    }
   
   
    /*
    
    Shamir's trick:
    The trick is to compute integers 𝑎,𝑏  s.t. 𝑎.x + 𝑏.y = 1.
    @return returnValue^(xy) = p1^x = p2^y = c modn
    Detail:
    returnValue = w1*w2 = p1^b * p2^a modn
    returnValue^(xy) modn= p1^bxy * p2^axy modn= (p1^x)^by * (p2^y)^ax modn = c^(ax + by)modn = c modn
    */

    function shamirTrick(p1, p2, x, y, n) {
      const [a, b, g] = extendedGcd(x, y);
      var w1 = p1.pow(BigNumber(b).toNumber()).mod(n.toNumber())
      var w2 = p2.pow(BigNumber(a).toNumber()).mod(n.toNumber())
      var result = (w1.times(w2.toNumber())).mod(n.toNumber())
      //console.log("w1 = " + w1.toNumber() + " w2 = "+ w2.toNumber() + "w1.times(w2).mod(n) = " + result)
      return result
    }

    /*
      Extended GCD algorithm.
      @return a,b,gcd(x,y)
     */
    function extendedGcd(x, y) {
     //console.log("1 x = " + x + " y = " + y)
     if (x.isZero()) {
      const a = BigNumber(0)
      const b = BigNumber(1)
      const gcd = y
      //console.log("x = " + x + " a = " + a.toNumber() + " b = " + b.toNumber()  + " gcd = " + gcd.toNumber())
      //console.log("x = " + x + " ax + by = " + (a.times(x).plus(b.times(y))).toNumber())
      return [BigNumber(a), BigNumber(b), BigNumber(gcd)]
     }
     const [a1, b1, g1] =extendedGcd(y.mod(x), x)
     //Math.floor在大数时会损失精度，所以改为如下
     const m1 = y.mod(x)
     const m2 = y.minus(m1)
     const ydx = BigNumber(m2.div(x))
     //const ydx = Math.floor(BigNumber(y.div(x)))
     //console.log("y.div(x) = " + y.div(x) + " ydx = " + ydx)
     const a = b1.minus(BigNumber(ydx).times(a1))
     const b = a1
     const gcd = g1
     //console.log("a = " + a.toNumber() + " b = " + b.toNumber()  + " gcd = " + gcd.toNumber())
     //console.log("2 x = " + x + " y = " + y)
     //console.log("ax + by = " + (a.times(x).plus(b.times(y))).toNumber())
     return [BigNumber(a), BigNumber(b), BigNumber(gcd)]
    }

   
   /******************************* Test Accumulator  **********************************************/
    var averageLoopTimes = 0
    var averageFindTime = 0 
    var loggestFindTime = 0
    var shortestFindTime = 99999999999999
   
   function Test(){//start

    /*
   
    var coins = [
      BigNumber(2),
      BigNumber(3),
      BigNumber(5),
      BigNumber(7),
    ]
    */
    var coins = new Array();
    for(i=0; i < 7; i++) {
      var addrToPrime = hashToPrime(testAddr[i])
      coins[i] = addrToPrime
    }

    var coinswithout2 = new Array();
    for(i=0; i < 7; i++) {
      if(i != 2){
        var addrToPrime = hashToPrime(testAddr[i])
        coins[i] = addrToPrime
      }
    }
    

    //构造累加器
    var addrNotIn = hashToPrime(testAddr[15])
    /*
    
    */
    //param 2: generator -> public
    const generator = new BigNumber(982451653);//982451653
    const salt = new BigNumber(5210644015679228794060694325390955853335898483908056458352183851018372555735221);
    accumulator = powInMod(generator,salt,N);
    console.log("accumulator before" + accumulator)
    for(i=0; i < coins.length; i++) {//加入累加器
      accumulator = RSAaccumulator.addItemToAccumulator(accumulator, coins[i]);
      console.log("accumulator add after" + coins[i] + " is " + accumulator)
    }
    //test proof
    const proof1 = RSAaccumulator.getProof(
        coins,
        coins[2],
        generator
    )
    if(RSAaccumulator.checkInclusionProof(accumulator, proof1) == false){
        console.log("Wrong proof1 coins[2] = " + coins[2] + " is not in accumulator")
    }else{
        console.log("Right proof1 coins[2] = " + coins[2] + " is in accumulator")
    }

    const proof2 = RSAaccumulator.getProof(
        coins,
        addrNotIn,
        generator
    )
    if(RSAaccumulator.checkInclusionProof(accumulator, proof2) == false){
        console.log("Wrong proof2 addrNotIn = " + addrNotIn + " is not in accumulator")
    }else{
        console.log("Right proof2 addrNotIn = " + addrNotIn + " is in accumulator")
    }
   
    //test modInverse
    console.log("start test modInverse *****************************")
    var y = coins[2]
    console.log("fn = " + modNum.fn.toNumber() + " y = " + y.toNumber())
    var inverseOfy = modInverse(y,modNum.fn)
    var vn = inverseOfy.times(y).mod(modNum.fn)
    console.log("vn should be 1 ,vn = " + vn)
    console.log("end test modInverse *****************************")


    //test delete Item
    console.log("start test delete Item *****************************")
    console.log("delete before = " + accumulator)
    var newAccmulatorWrong = RSAaccumulator.deleteItemFromAccumulator(accumulator,addrNotIn, proof2)
    var newAccmulatorRight = RSAaccumulator.deleteItemFromAccumulator(accumulator,coins[2],proof1)
    console.log("delete after = " + newAccmulatorRight)
    const proof11 = RSAaccumulator.getProof(
        coinswithout2,
        coins[2],
        generator
    )
    //should be Wrong
    if(RSAaccumulator.checkInclusionProof(newAccmulatorRight, proof11) == false){
        console.log("Wrong proof1 coins[2] = " + coins[2] + " is not in accumulator")
    }else{
        console.log("Right proof1 coins[2] = " + coins[2] + " is in accumulator")
    }

    console.log("end test delete Item  *****************************")
    
   }


    Test()
 
 
 // hashToPrime 
 //test result:hashToPrimeTestResult.txt
    function hashToPrime(address){
      //lengthChoose = 17 包含了前两位0x，实际对应15位16进制数 max = 16^16 - 1 = 18446744073709552000
      //ln(18446744073709552000) = 44, 由素数定理得素数大概有  n/ln（n） = 4.19244183e17 个
      //平均需要 4e17 次测试才能碰撞出相同素数，一次测试平均又需要循环1000次，js语言下耗时1000ms，故需4e17秒才能碰撞出一个相同素数
      //假设用户加入10个地址到累加器，那么攻击者需要碰撞4e17 / 10 = 4e16秒 = 18446744073709552000/（44*10*3600*24*365）=1.32e9年
      const lengthChoose = 17
      var addrToHash = web3js.utils.sha3(address)
      var addrBN = BigNumber(addrToHash.substring(0,lengthChoose))
      var probablyPrimeTimes = 0
      var start = getTime()
      while(1){
        probablyPrimeTimes++;
        var isprime = probablyPrime(addrBN,10)
        if(isprime == true){
          var end = getTime()
          console.log("probablyPrime times = " + probablyPrimeTimes )
          console.log("time used : " + (end-start) + " ms ")
          console.log("!!! find prime = " + addrBN.toNumber() + " for " + address)
          averageFindTime += end - start
          averageLoopTimes += probablyPrimeTimes
          loggestFindTime = (end - start)>loggestFindTime?(end - start):loggestFindTime
          shortestFindTime = (end - start)<shortestFindTime?(end - start):shortestFindTime
          break;
        }else{
          var addrToHash = web3js.utils.sha3(addrToHash)
          var addrBN = BigNumber(addrToHash.substring(0,lengthChoose))
        }
      }
      return addrBN;
    }
    
    /*
    Miller–Rabin primality test 
    n -> 被测试数 (BigNumber) k -> 测试次数
    取k = 10，一个非素数通过10次测试的概率小于10^-6
    */
    function probablyPrime(n, k) {
      
     	if (n.toNumber() === 2  || n.toNumber() === 3)
   		return true;
    	if (n.mod(2).toNumber() === 0 || n.toNumber() < 2)
	  	return false;

    	//Write (n - 1) as 2^s * d
      //k = s, q = d
    	var s = 0, d = BigNumber(n.toNumber() - 1);
    	while ((d.mod(2)).toNumber() === 0) {
	      d =	d.div(2);
		    ++s;
     	}

   	  WitnessLoop: do {
        //console.log("testing... " + n.toNumber())
	    	//a : A base between 2 and n - 2
        var nx = n.toNumber() - 3
        var nxx = 2 + Math.floor(Math.random() * nx)
        var a = BigNumber(nxx)
       
	    	var x = powInMod(a, d ,n)
       // console.log("a = " + a.toNumber() + " x = " + x.toNumber())
        //1， if a^q mod n =1, then "not sure"
	  	  if (x.toNumber() === 1)
          //console.log("pass con 1")
		  	  continue ;//pass
        //2， for(j=0 to k-1) do
        //       if a^(2^j * q) mod n =1, then "not sure"
	   	  for (var j = 0;j < s; j++) {
          var t = Math.pow(2,j)*d
          var r = powInMod(a,BigNumber(t) ,n)
		    	if (r.toNumber() === (n.toNumber() - 1))
            //console.log("pass con 2")
			  	  continue WitnessLoop;//pass
		    }
        if(j == s)
          return false//2 not satisfied
	    } while (--k);

	    return true;
    }
    
    function getTime(){
      var now = Date.now();
      return now 
    }

    </script>
  </body>
</html>
 