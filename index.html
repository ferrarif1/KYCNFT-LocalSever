<!DOCTYPE html>
<html lang="en">
   <head>
    <meta charset="UTF-8">
    <title>KYCManager front-end</title>
    <script language="javascript" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://unpkg.com/@metamask/detect-provider/dist/detect-provider.min.js"></script>
    <script language="javascript" type="text/javascript" src="./src/js/web3.min.js"></script>
    <script language="javascript" type="text/javascript" src="./src/js/KYCManager_ABI.js"></script>
    <script language="javascript" type="text/javascript" src="./src/js/KYCNFT_ABI.js"></script>
    <script language="javascript" type="text/javascript" src="./src/js/testAddress.js"></script>
    <script language="javascript" type="text/javascript" src="./src/js/bignumber.js"></script>

     
    
    
   
    
  </head>
  <body>
    <div id="txStatus"></div>
    <input type="text" id="inputOwnerAddr" oninput="getOwnerAddr();" onporpertychange="getOwnerAddr();" placeholder="CreateKYCNFT for owner address">
    <button class="createKYCNFTButton btn">CreateKYCNFT</button><br>
    <button class="enableEthereumButton btn">Enable Ethereum</button>
    <button class="sendEthButton btn">Send Eth</button>
    <button class="updateAccumulatorButton btn">update Accumulator For Owner</button>
    <script>
      /*
        KYCManager Owner：0x892953Cb6cDC87c8aD7c4aAfb06A716CBa231D8a
      */
      
      var KYCManager;
      var KYCManagerAddress = "0x6D847221B1cF6c4d2bfDb3956073A430240f2512";
      
      var web3js =  window.web3 ? new Web3(window.web3.currentProvider) : new Web3(new Web3.providers.HttpProvider("https://goerli.infura.io/v3/de1e8657274a494aa59476341cafc010"));;
      
     
      
      function startApp() {
        console.log(" ******  start App   ******")
        
        KYCManager = new web3js.eth.Contract(kycManagerABI, KYCManagerAddress);
        
        //test
        getOwnerOfNFTid(4).then(function(result, error) {
         if(error){
           console.log(error);
         }
         else{
           var strA = "0x0000000000000000000000000000000000000000";
           var strB = new String(result);
           if(strA == strB){
              console.log("NFT not exist!")
           }else{
              console.log("OwnerOfNFTid 4: " + JSON.stringify(result))
           }
           
         }
        });
        
        //test 
        getAccumulatorOfOwner('0xE338401152596583EeC184061F504D7600B59Ea6').then(function(result, error) {
         if(error){
           console.log(error);
         }
         else{
           console.log("AccumulatorAddrOfOwner: " + JSON.stringify(result));
         }
        });
        //获取metamask账户
        getAccount();
        

        
        
      }
      
      
    
       /********************************************************    Call Contract by web3js      **************************************************************************************/
      


      /*
      getBalance
      */
      function getBalance(address){
         web3js.eth.getBalance(address,function(error,result){
         if(error){
           console.log(error)
         }
         else{
           console.log(result)
           
         }
        }) 
      }
      
       
      
    /*
       (1) 创建NFT（ owner权限）
    */
      
       function createKYCNFT(tokenUrl, manager) {
        $("#txStatus").text("Creating KYCNFT on the blockchain. This may take a while...");

        return KYCManager.methods.createKYCNFT(tokenUrl, manager)
        .send({ from: web3.eth.accounts[0]})
        .on("receipt", function(receipt) {
          $("#txStatus").text("Successfully created " + tokenUrl + "for manager" + manager + "!");
        })
        .on("error", function(error) {
          $("#txStatus").text(error);
        });
    
      }
      
      
    /*
       (2) 设置NFT有效性
    */
       function setKYCNFTAvailable(NFTid, available) {
        $("#txStatus").text("Set KYCNFT Available This may take a while...");
        
        return KYCManager.methods.setNFTAvailable(NFTid, available)
        .send({ from: web3.eth.accounts[0]})
        .on("receipt", function(receipt) {
          $("#txStatus").text("Successfully set " + NFTid + "to Available" + available + "!");
        })
        .on("error", function(error) {
          $("#txStatus").text(error);
        });
      }
      
      
      
     /*
      （3）Map1:绑定NFTid与管理地址
     */
 
     //create是owner权限
       function createNFTidToManagerAddr(NFTid, manager) {
        $("#txStatus").text("Set create NFTid to ManagerAddr This may take a while...");

        return KYCManager.methods.createNFTidToManagerAddr(NFTid, manager)
        .send({ from: web3.eth.accounts[0]})
        .on("receipt", function(receipt) {
          $("#txStatus").text("Successfully create NFTid " + NFTid + "to ManagerAddr" + manager + "!");
        })
        .on("error", function(error) {
          $("#txStatus").text(error);
        });
   
 
      }  
    //modify是Manager addr权限
      function modifyNFTidToManagerAddr(NFTid, newManager) {
        $("#txStatus").text("Set modify NFTid to ManagerAddr. This may take a while...");
        
        return KYCManager.methods.modifyNFTidToManagerAddr(NFTid, newManager)
        .send({ from: web3.eth.accounts[0]})
        .on("receipt", function(receipt) {
          $("#txStatus").text("Successfully modify NFTid " + NFTid + "to ManagerAddr" + newManager + "!");
        })
        .on("error", function(error) {
          $("#txStatus").text(error);
        });
      }



    /*
      （4）Map2:绑定管理地址与累加器（查询管理地址已经有了对应的KYCNFT）
    */
      function updateAccumulator(Accumulator) {
        $("#txStatus").text("Bind Manger to Accumulator. This may take a while...");
        
        return KYCManager.methods.updateAccumulator(addrOfAccumulator)
        .send({ from: web3.eth.accounts[0]})
        .on("receipt", function(receipt) {
          $("#txStatus").text("Successfully update Manger " + web3.eth.accounts[0] + "to addrOfAccumulator" + addrOfAccumulator + "!");
        })
        .on("error", function(error) {
          $("#txStatus").text(error);
        });
      }
  
  
      
      
    /*
       （5）查询某NFT id对应的管理地址与累加器地址
    */
      //由NFTid 找Owner地址
      function getOwnerOfNFTid(id) {
        return KYCManager.methods.ownerOfNFTid(id).call()
      }
      
       //由NFTid 找Accumulator
      function getAccumulatorOfNFTID(id) {
        return KYCManager.methods.accumulatorOfNFTID(id).call()
      }
      
      //由Owner 找Accumulator
      function getAccumulatorOfOwner(owner) {
        return KYCManager.methods.accumulatorOfOwner(owner).call()
      }
      
       //由NFTid查询有效性
      function getAvailableOfNFTid(id) {
        return KYCManager.methods.availableOfNFTid(id).call()
      }
       //由Manager addr找由NFTid
      function getNFTidOfOwner(owner) {
        return KYCManager.methods.NFTidOfOwner(owner).call()
      }
     
     /********************************************************    UI      **************************************************************************************/
     
    var ownerAddr = document.getElementById("inputOwnerAddr").value;;
    function getOwnerAddr(){
	    ownerAddr = document.getElementById("inputOwnerAddr").value;
		console.log("inputOwnerAddr = " + ownerAddr);
	}



    const ethereumButton = document.querySelector('.enableEthereumButton');
    const sendEthButton = document.querySelector('.sendEthButton');
    const createKYCNFTButton = document.querySelector('.createKYCNFTButton');
    const updateAccumulatorButton = document.querySelector('.updateAccumulatorButton');
    let accounts = [];

    ethereumButton.addEventListener('click', () => {
       getAccount();
    });

    sendEthButton.addEventListener('click', () => {
       ethereum
      .request({
         method: 'eth_sendTransaction',
         params: [
         {
          from: accounts[0],
          to: '0xE338401152596583EeC184061F504D7600B59Ea6',
          value: '0x29a2241af62c0000',
          gasPrice: '0x09184e72a000',
          gas: '0x2710',
         },
       ],
       })
      .then((txHash) => console.log(txHash))
      .catch((error) => console.error);
    });
   
    async function getAccount() {
       accounts = await ethereum.request({ method: 'eth_requestAccounts' });
    }
    
   
    createKYCNFTButton.addEventListener('click', () => {
    
        
        createKYCNFT("ipfs://ipfsHash",ownerAddr).then(function(result, error) {
         if(error){
           console.log(error)
         }
         else{
           console.log("create KYCNFT Success !: " + JSON.stringify(result));
         }
        });
        
    });
    
    updateAccumulatorButton.addEventListener('click', () => {
        
        updateAccumulator(BigNumber(162259276829213363391578010288127)).then(function(result, error) {
         if(error){
           console.log(error)
         }
         else{
           console.log("update Accumulator Success !: " + JSON.stringify(result));
         }
        });
        
    });



     /*
    ***********************************************************     Metamask check      *****************************************************************************************
    
    What metamask do is inject javascript into the document when you access it. The browser will execute this javascript, and is that execution that will define de variable web3.

    But when you are accessing a document by accessing the file (your url will start with file://) then metamask will not inject the javascript, so the variable web3 will be undefined.

    Try accessing your file through a web server of some sort and it will work.
    
     */
   

    
    window.addEventListener('load', function() {

       _Connect()
      
       startApp(); 
    }) 
     
     
     
   /*
   mainnet	ETH	1	1	Production
   ropsten	ETH	3	3	Test
   rinkeby	ETH	4	4	Test
   goerli	ETH	5	5	Test
   */
    
   function _Connect(){

    if(typeof window.ethereum !== 'undefined') {
        if(web3js.currentProvider.isMetaMask){
          console.log("CurrentProvider is MetaMask");
        }else {
          console.log(`Failed: Web3 instance required, try using MetaMask.`);
          alert('Install Metamask');
        } 
       
        console.log("netId = " + web3js.currentProvider.networkVersion)
        switch (web3js.currentProvider.networkVersion) {
          case "1":
           // alert('Ethereum MainNet'); 
            console.log('Ethereum MainNet');
            break
          case "3":
           // alert('Ethereum Ropsten'); 
            console.log('Ethereum Ropsten');
            break    
          case "4":
            //alert('Ethereum Rinkeby'); 
            console.log('Ethereum Rinkeby');
            break   
          case "5":
            //alert('Ethereum Goerli'); 
            console.log('Ethereum Goerli');
            break   
            
          default:
            console.log('This is an unknown network.');
            alert('Switch Network');
        }
        web3.eth.defaultAccount = web3.eth.accounts[0];
        if(!web3.eth.defaultAccount){
            console.log('Log into metamask');
            _Connect(callback);
        }else{ 
            // Success
            console.log(`Web3 ETH Account: ${web3.eth.defaultAccount}`);
        } 
              
    }
    }
          
   
    /********************************************************    Accumulator      **************************************************************************************/
   

    function powInMod(a, y, z) {
      let x = BigNumber(1);
      while(y.comparedTo(0) == 1) {
        if(y.mod(2).toNumber() === 1) {
          x = (x.times(a)).mod(z);
          y = y.minus(1);
        }
        y = y.div(2);
        a = a.times(a).mod(z);
      }
      return x;
    }

    // should be big. And the prime factors of N should be unknown to anyone. 
    const N = new BigNumber(70368760954879);
   
    class RSAaccumulator {
      
      static updateAccumulator(accumulator, value) {
        return powInMod(accumulator, value, N);
      }

      static deleteItemFromAccumulator(coins,generator,accumulator,valueToDelete) {
        //shamirTrick(p1, p2, x, y, n) 
        // suppose x = 1, delete y from old accumulator c = c^1 = p2^y modn,
        // p1 = old accumulator, x = 1
        // p2 = witness of y , y ->going to be deleted
        //  returnValue^(xy) =  returnValue^(y) = c modn,
        //  then returnValue become the new accumulator c‘,c' do not have y
        let p1 = accumulator
        let wit = generator
        console.log("wit before" + wit)
        for(i=0; i < coins.length; i++) {
          if(coins[i].toNumber() != valueToDelete.toNumber()){
            wit = RSAaccumulator.updateAccumulator(wit, coins[i]);
            console.log("wit add after" + coins[i] + " is " + wit)
          } 
        }
        let p2 =  wit
        let x = BigNumber(1)
        let y = valueToDelete
        let newAccumulator = shamirTrick(p1, p2, x, y, N)     
        return  newAccumulator
      }
      
      static hash(value) {
        const hash = '0x' + Web3.utils.keccak256(value.toString()).toString('hex')
        return new BigNumber(hash);
      }
      
     static getProof(setValues, value, generator, accumulator){
       // calcute (q,r,x). it satisfies q**B * g**(vr)* g**x == A
       // h = generator^value, B = hash(h+accumulator) ,
       let h = powInMod(generator, value, N);
       let B = RSAaccumulator.hash(h.plus(accumulator));
       let q = BigNumber(1);
       let r = BigNumber(0);
       let x = BigNumber(1);
       for(let i = 0; i < setValues.length; i++){
         let x2 = (x.times(setValues[i])).mod(value);
         let temp = ((x.times(setValues[i])).div(value))
                     .plus(r.times(setValues[i]))
                     .integerValue(BigNumber.ROUND_FLOOR);
         let r2 = temp.mod(B);
         let q2 = powInMod(BigNumber(1), setValues[i], N)
                   .times(powInMod(h, (temp.div(B)).integerValue(BigNumber.ROUND_FLOOR), N))
                   .mod(N);
         x = x2;
         r = r2;
         q = q2;
       }
       console.log('get proof', q.toNumber(), r.toNumber(), x.toNumber());
       return new RSAaccumulatorProof(value, q, r, x);
     }
   
     static checkNonInclusionProof(generator, accumulator, proof) {
       let h = powInMod(generator, proof.value, N);
       let B = RSAaccumulator.hash(h.plus(accumulator));
       if(proof.x.comparedTo(0) <= 0 || proof.value.comparedTo(proof.x) <= 0){
         return false;
       }
       if(proof.r.comparedTo(0) <= 0 || B.comparedTo(proof.r) <= 0){
         return false;
       }
       if(powInMod(proof.q, B, N).times(powInMod(generator, proof.r.times(proof.value).plus(proof.x), N)).mod(N).eq(accumulator)) {
         return true;
       }else{
         return false;
       }
     }

     static checkInclusionProof(generator, accumulator, proof){
       let h = powInMod(generator, proof.value, N);
       let B = RSAaccumulator.hash(h.plus(accumulator));
       if(!proof.x.eq(0)){
         return false;
       }
       if(proof.r.comparedTo(0) <= 0 || B.comparedTo(proof.r) <= 0){
         return false;
       }
       if(powInMod(proof.q, B, N).times(powInMod(generator, proof.r.times(proof.value).plus(proof.x), N)).mod(N).eq(accumulator)){
           return true;
       }else{
           return false;
       }
     }
   }

    class RSAaccumulatorProof{
         constructor(value,q,r,x){
           this.value=value;
           this.q=q;
           this.r=r;
           this.x=x;
         }
    }
    /*

    Shamir's trick: Given n,p1,p2,x,y  s.t. p1^x = p2^y modn, and x,y are relatively primes, you can efficiently find p2^(1/𝑒)mod𝑁. 
    The trick is to compute integers 𝑎,𝑏  s.t. 𝑎.x + 𝑏.y = 1.
    @return returnValue^(xy) = p1^x = p2^y = c modn
    */

    function shamirTrick(p1, p2, x, y, n) {
      const [a, b, g] = extendedGcd(x, y);
      var w1 = p1.pow(BigNumber(b).toNumber()).mod(n.toNumber())
      var w2 = p2.pow(BigNumber(a).toNumber()).mod(n.toNumber())
      var result = (w1.times(w2.toNumber())).mod(n.toNumber())
      console.log("w1 = " + w1.toNumber() + " w2 = "+ w2.toNumber() + "w1.times(w2).mod(n) = " + result)
      return result
    }

    /*
      Extended GCD algorithm.
     */
    function extendedGcd(x, y) {
     if (x.isZero()) {
      const a = BigNumber(0);
      const b = BigNumber(1);
      const gcd = y
      return [BigNumber(a), BigNumber(b), BigNumber(gcd)]
     }
     const [a1, b1, g1] =extendedGcd(y.mod(x), x)
     const ydx = BigNumber(y.div(x))
     const resb = BigNumber(b1)
     const a = resb.minus(ydx.times(a1))
     const b = a1
     const {gcd} = g1
     return [BigNumber(a), BigNumber(b), BigNumber(gcd)]
    }

   
    var averageLoopTimes = 0
    var averageFindTime = 0 
    var loggestFindTime = 0
    var shortestFindTime = 99999999999999

   function Test(){//start

    var coins = new Array();
    /*  目前加入数量>7会出错  */
    for(i=0; i < 7; i++) {//第0-4地址hash加入数组
      var addrToPrime = hashToPrime(testAddr[i])
      coins[i] = addrToPrime
    }
    var addrNotIn = hashToPrime(testAddr[15])
    const generator = new BigNumber(982451653);
    accumulator = generator;
    console.log("accumulator before" + accumulator)
    for(i=0; i < coins.length; i++) {//加入累加器
      accumulator = RSAaccumulator.updateAccumulator(accumulator, coins[i]);
      console.log("accumulator add after" + coins[i] + " is " + accumulator)
    }

    //删除coin[8]
    // console.log("accumulator delete before " + coins[1] + " is " + accumulator)
    // accumulator = RSAaccumulator.deleteItemFromAccumulator(coins, generator, accumulator, coins[1]);
    // console.log("accumulator delete after " + coins[1] + " is " + accumulator)

     //coin[2] 成员证明 Right proof
    const proof = RSAaccumulator.getProof(
        coins,
        coins[2],
        generator,
        accumulator);
    if(RSAaccumulator.checkInclusionProof(generator, accumulator, proof) == false){
        console.log("Wrong proof1")
    }else{
        console.log("Right proof1")
    }
     //addrNotIn 成员证明 Wrong proof
    const proof2 = RSAaccumulator.getProof(
        coins,
        addrNotIn,
        generator,
        accumulator);
    if(RSAaccumulator.checkInclusionProof(generator, accumulator, proof2) == false){
        console.log("Wrong proof2")
    }else{
        console.log("Right proof2")
    }


   
  
   }


    Test()
 
 
 // hashToPrime 
 //test result see:hashToPrimeTestResult.txt
    

    function hashToPrime(address){
      var addrToHash = web3js.utils.sha3(address)
      var addrBN = BigNumber(addrToHash.substring(0,10))
      var probablyPrimeTimes = 0
      var start = getTime()
      while(1){
        probablyPrimeTimes++;
        var lengthChoose = 17
        var isprime = probablyPrime(addrBN,lengthChoose)
        if(isprime == true){
          var end = getTime()
          console.log("probablyPrime times = " + probablyPrimeTimes )
          console.log("time used : " + (end-start) + " ms ")
          console.log("!!! find prime = " + addrBN.toNumber() + " for " + address)
          averageFindTime += end - start
          averageLoopTimes += probablyPrimeTimes
          loggestFindTime = (end - start)>loggestFindTime?(end - start):loggestFindTime
          shortestFindTime = (end - start)<shortestFindTime?(end - start):shortestFindTime
          break;
        }else{
          var addrToHash = web3js.utils.sha3(addrToHash)
          var addrBN = BigNumber(addrToHash.substring(0,lengthChoose))
        }
      }
      return addrBN;
    }
    
    /*
    Miller–Rabin primality test 
    n -> 被测试数 (BigNumber) k -> 测试次数
    取k = 10，一个非素数通过10次测试的概率小于10^-6
    */
    function probablyPrime(n, k) {
      
     	if (n.toNumber() === 2  || n.toNumber() === 3)
   		return true;
    	if (n.mod(2).toNumber() === 0 || n.toNumber() < 2)
	  	return false;

    	//Write (n - 1) as 2^s * d
      //k = s, q = d
    	var s = 0, d = BigNumber(n.toNumber() - 1);
    	while ((d.mod(2)).toNumber() === 0) {
	      d =	d.div(2);
		    ++s;
     	}

   	  WitnessLoop: do {
        //console.log("testing... " + n.toNumber())
	    	//a : A base between 2 and n - 2
        var nx = n.toNumber() - 3
        var nxx = 2 + Math.floor(Math.random() * nx)
        var a = BigNumber(nxx)
       
	    	var x = powInMod(a, d ,n)
       // console.log("a = " + a.toNumber() + " x = " + x.toNumber())
        //1， if a^q mod n =1, then "not sure"
	  	  if (x.toNumber() === 1)
          //console.log("pass con 1")
		  	  continue ;//pass
        //2， for(j=0 to k-1) do
        //       if a^(2^j * q) mod n =1, then "not sure"
	   	  for (var j = 0;j < s; j++) {
          var t = Math.pow(2,j)*d
          var r = powInMod(a,BigNumber(t) ,n)
		    	if (r.toNumber() === (n.toNumber() - 1))
            //console.log("pass con 2")
			  	  continue WitnessLoop;//pass
		    }
        if(j == s)
          return false//2 not satisfied
	    } while (--k);

	    return true;
    }
    
    function getTime(){
      var now = Date.now();
      return now 
    }
  
    </script>
  </body>
</html>
 